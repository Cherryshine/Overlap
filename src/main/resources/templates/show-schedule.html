<!DOCTYPE html>
<html lang="ko">  
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>OverLap - 메인 랜딩페이지</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet"/>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet"/>
    <link href="https://ai-public.creatie.ai/gen_page/tailwind-custom.css" rel="stylesheet"/>
    <script src="https://cdn.tailwindcss.com/3.4.5?plugins=forms@0.5.7,typography@0.5.13,aspect-ratio@0.4.2,container-queries@0.1.1"></script>
    <script src="https://ai-public.creatie.ai/gen_page/tailwind-config.min.js" data-color="#000000" data-border-radius="small"></script>
    <script src="/js/navBar.js"></script>
    <style>
        .glass-effect {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 1rem; /* 동일한 곡률을 적용 */
        }
        @keyframes float {
            0% { transform: translateY(0); }
            50% { transform: translateY(-2px); }
            100% { transform: translateY(0); }
        }
        .logo-animation {
            animation: float 2s ease-in-out infinite;
        }
        .full-screen {
            min-height: 100vh;
        }
        .chat-message {
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.7s ease, transform 0.7s ease;
        }
        @keyframes expand {
            0% {
                opacity: 0;
                transform: scale(0.5);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }
        .animate-expand {
            animation: expand 0.6s ease-out;
            transform-origin: top;
        }

        /* 버튼 애니메이션 */
        .btn-animate {
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.7s ease, transform 0.7s ease;
        }
        .btn-show {
            opacity: 1;
            transform: translateY(0);
        }

        /* 전체 레이아웃을 flex로 설정하여 푸터를 하단에 고정 */
        body, html {
            height: auto;  /* 고정 높이 대신 자동으로 조정 */
            margin: 0;
            display: flex;
            flex-direction: column;
        }

        .content {
            flex-grow: 1;
            min-height: 100vh;  /* 컨텐츠의 최소 높이 설정 */
        }

        footer {
            margin-top: auto; /* 푸터를 하단에 고정 */
        }

        /* 그라데이션 배경 설정 */
        body {
            background-size: 100% auto;  /* 너비 100%, 높이는 자동으로 조정 */
            background-repeat: no-repeat;
            min-height: 100%;  /* 최소 높이를 100%로 설정 */
        }

        /* 320px 이하 화면에서 버튼 텍스트 크기를 12px로 적용 (Tailwind보다 우선순위를 높임) */
        @media (max-width: 320px) {
            button.btn-responsive-text {
                font-size: 12px !important;
            }
        }

        /* 반응형 버튼 폰트: 뷰포트 너비가 320px에서는 12px, 640px 이상에서는 16px로 선형 보간 */
        .btn-responsive-font {
            font-size: clamp(12px, calc(12px + ((100vw - 320px) / 80)), 16px) !important;
        }

        /* 셀 내부 텍스트 색상 설정 */
        .grid-cell {
            color: white;
        }
        
        /* 셀 내부의 모든 텍스트 요소에 대한 색상 설정 */
        .grid-cell * {
            color: white;
        }
        
        /* 헤더 텍스트는 제외 (요일, 날짜 표시) */
        .text-center .text-sm,
        .text-center .text-lg {
            color: inherit;
        }

        /* 모든 셀 내부 텍스트를 흰색으로 설정 */
        .grid-cell span {
            color: white !important;
        }
        
        /* 셀 내부의 모든 텍스트 요소에 대해 흰색 적용 */
        .grid-cell * {
            color: white !important;
        }

        /* 선택된 셀 정보 영역의 스타일 */
        #selectedCellInfo h3 {
            color: #6B46C1 !important; /* text-purple-800 */
        }
        
        #selectedCellInfo p {
            color: #7C3AED !important; /* text-purple-600 */
        }
        
        #selectedCellInfo span {
            background-color: #F3E8FF !important; /* bg-purple-100 */
            color: #6B46C1 !important; /* text-purple-800 */
        }
    </style>
    <script src="https://cdn.tailwindcss.com/3.3.2"></script>

    <style>
        /* iOS에서 더블탭 확대 방지 */
        * {
            touch-action: manipulation;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        /* 페이지 버튼 (공통) */
        .page-button {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
            border-radius: 4px; /* 둥근 모서리 사각형 형태 */
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
            cursor: pointer;
            flex-shrink: 0;
        }

        .page-button:disabled {
            opacity: 0.5;
            cursor: default;
        }

        /* 스크롤 영역 내에 상단과 하단에 고정될 버튼 */
        .page-button-prev {
            position: sticky;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
        }

        .page-button-next {
            position: sticky;
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
        }

        /* 반응형 설정 */
        @media (max-width: 629px) {
            .page-button {
                width: 28px;
                height: 28px;
            }
        }
        .grid-cell {
            position: relative;
            overflow: hidden;
        }

        /* 시간 구분선을 위한 가상 요소 */
        .grid-cell::before {
            content: '';
            position: absolute;

            left: -8px; /* 부모의 패딩만큼 음수값 */
            right: -8px; /* 부모의 패딩만큼 음수값 */
            top: 0;
            height: 1px;
            background-color: rgb(209, 213, 219);
            z-index: 1;
        }

        /* 시간대 구분선(검은색 굵은 선)의 경우 */
        .grid-cell.hour-mark::before {
            height: 1.2px;
            background-color: rgb(157, 101, 203);
        }

        /* 첫 번째 행의 셀은 border 제거 */
        .grid-row-first .grid-cell::before {
            display: none;
        }

        /* 로딩 애니메이션 관련 스타일 */
        .skeleton-loader {
            position: relative;
            background: #f0e9fb;
            border-radius: 6px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(157, 101, 203, 0.08);
        }
        
        /* 빛 막대 효과 1 - 첫 번째 막대 */
        .skeleton-loader::after {
            content: '';
            position: absolute;
            top: 0;
            left: -150px;
            height: 100%;
            width: 150px;
            background: linear-gradient(to right, 
                rgba(255, 255, 255, 0) 0%,
                rgba(255, 255, 255, 0.5) 50%,
                rgba(255, 255, 255, 0) 100%
            );
            animation: shimmer-wave 1.5s cubic-bezier(0.4, 0.0, 0.2, 1) infinite;
        }
        
        /* 빛 막대 효과 2 - 두 번째 막대 (시차를 둠) */
        .skeleton-loader::before {
            content: '';
            position: absolute;
            top: 0;
            left: -150px;
            height: 100%;
            width: 150px;
            background: linear-gradient(to right, 
                rgba(255, 255, 255, 0) 0%,
                rgba(255, 255, 255, 0.5) 50%,
                rgba(255, 255, 255, 0) 100%
            );
            animation: shimmer-wave 1.5s cubic-bezier(0.4, 0.0, 0.2, 1) 0.75s infinite;
        }
        
        @keyframes shimmer-wave {
            0% {
                transform: translateX(-150px);
            }
            100% {
                transform: translateX(1000px);
            }
        }
        
        /* 중첩된 그리드에서 시차를 두지 않고 동일한 물결이 지나가도록 수정 */
        .loader-container {
            padding: 16px;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }
        
        .loader-header {
            display: flex;
            height: 36px;
            gap: 8px;
            margin-bottom: 20px;
        }
        
        .loader-time-column {
            width: 60px;
            margin-right: 12px;
            display: flex;
            flex-direction: column;
            gap: 40px;
        }
        
        .loader-time {
            width: 52px;
            height: 20px;
        }
        
        .loader-grid-container {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .loader-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 4px;
            margin-bottom: 10px;
        }
        
        .loader-cell {
            height: 26px;
            border-radius: 4px;
        }
        
        /* 펄싱 효과 (약간의 크기 변화) */
        @keyframes pulse {
            0%, 100% {
                transform: scaleY(1);
            }
            50% {
                transform: scaleY(0.97);
            }
        }
        
        .skeleton-loader {
            animation: pulse 3s ease-in-out infinite;
        }
        
        /* 등장 애니메이션 */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(8px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .loader-container {
            animation: fadeIn 0.3s ease-out forwards;
        }
        
        .hidden {
            display: none;
        }
    </style>
</head>
<body class="flex flex-col bg-gradient-to-br from-purple-200 via-purple-300 to-purple-400">

<div th:replace="~{/navigation-bar :: nav}"></div>

<!-- main 태그로 콘텐츠 영역을 감싸 flex-grow 속성을 적용 -->
<main class="content pt-[84px] sm:pt-[150px]">
    <div class="container mx-auto px-4 sm:px-6 md:px-8 lg:px-[60px] pb-[50px] max-w-4xl">
        <div class="glass-effect rounded-3xl p-8 text-center">
            <!-- 일정 제목 -->
            <p class="text-purple-800 mb-[15px] text-3xl">
                <a class="text-purple-800 mb-[15px] font-bold text-3xl">{schedule.title}</a> 그룹 일정
            </p>
            <!-- 타임 테이블 -->
            <div id="app" class="max-w-5xl w-full p-4 bg-purple-50 rounded-lg shadow relative">
                <!-- 로딩 애니메이션 추가 -->
                <div id="scheduleLoader" class="loader-container">
                    <!-- 헤더 스켈레톤 -->
                    <div class="loader-header">
                        <div class="skeleton-loader w-16"></div>
                        <div class="skeleton-loader flex-1"></div>
                    </div>
                    
                    <!-- 시간표 본문 -->
                    <div class="flex">
                        <!-- 시간 마커 열 -->
                        <div class="loader-time-column">
                            <div class="loader-time skeleton-loader"></div>
                            <div class="loader-time skeleton-loader"></div>
                            <div class="loader-time skeleton-loader"></div>
                            <div class="loader-time skeleton-loader"></div>
                        </div>
                        
                        <!-- 그리드 스켈레톤 -->
                        <div class="loader-grid-container">
                            <!-- 반복되는 행 7개 (시간대별) -->
                            <div class="loader-grid">
                                <div class="loader-cell skeleton-loader"></div>
                                <div class="loader-cell skeleton-loader"></div>
                                <div class="loader-cell skeleton-loader"></div>
                                <div class="loader-cell skeleton-loader"></div>
                                <div class="loader-cell skeleton-loader"></div>
                            </div>
                            <div class="loader-grid">
                                <div class="loader-cell skeleton-loader"></div>
                                <div class="loader-cell skeleton-loader"></div>
                                <div class="loader-cell skeleton-loader"></div>
                                <div class="loader-cell skeleton-loader"></div>
                                <div class="loader-cell skeleton-loader"></div>
                            </div>
                            <div class="loader-grid">
                                <div class="loader-cell skeleton-loader"></div>
                                <div class="loader-cell skeleton-loader"></div>
                                <div class="loader-cell skeleton-loader"></div>
                                <div class="loader-cell skeleton-loader"></div>
                                <div class="loader-cell skeleton-loader"></div>
                            </div>
                            <div class="loader-grid">
                                <div class="loader-cell skeleton-loader"></div>
                                <div class="loader-cell skeleton-loader"></div>
                                <div class="loader-cell skeleton-loader"></div>
                                <div class="loader-cell skeleton-loader"></div>
                                <div class="loader-cell skeleton-loader"></div>
                            </div>
                            <div class="loader-grid">
                                <div class="loader-cell skeleton-loader"></div>
                                <div class="loader-cell skeleton-loader"></div>
                                <div class="loader-cell skeleton-loader"></div>
                                <div class="loader-cell skeleton-loader"></div>
                                <div class="loader-cell skeleton-loader"></div>
                            </div>
                            <div class="loader-grid">
                                <div class="loader-cell skeleton-loader"></div>
                                <div class="loader-cell skeleton-loader"></div>
                                <div class="loader-cell skeleton-loader"></div>
                                <div class="loader-cell skeleton-loader"></div>
                                <div class="loader-cell skeleton-loader"></div>
                            </div>
                            <div class="loader-grid">
                                <div class="loader-cell skeleton-loader"></div>
                                <div class="loader-cell skeleton-loader"></div>
                                <div class="loader-cell skeleton-loader"></div>
                                <div class="loader-cell skeleton-loader"></div>
                                <div class="loader-cell skeleton-loader"></div>
                            </div>
                            <div class="loader-grid">
                                <div class="loader-cell skeleton-loader"></div>
                                <div class="loader-cell skeleton-loader"></div>
                                <div class="loader-cell skeleton-loader"></div>
                                <div class="loader-cell skeleton-loader"></div>
                                <div class="loader-cell skeleton-loader"></div>
                            </div>
                            <div class="loader-grid">
                                <div class="loader-cell skeleton-loader"></div>
                                <div class="loader-cell skeleton-loader"></div>
                                <div class="loader-cell skeleton-loader"></div>
                                <div class="loader-cell skeleton-loader"></div>
                                <div class="loader-cell skeleton-loader"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- (1) 스크립트 파일 로드 -->
            <script src="/js/schedule.js"></script>

            <!-- (2) JSON 데이터 및 초기화 로직 -->
            <script>
                // 서버에서 데이터 가져오기 함수
                async function fetchScheduleData() {
                    try {
                        // 로더 표시
                        document.getElementById('scheduleLoader').classList.remove('hidden');
                        
                        // 참여자 리스트와 가능한 시간대를 포함한 더미 데이터
                        const data = {
                            startTime: "11:00",
                            endTime: "16:00",
                            interval: 15,
                            days: [
                                { label: "월", date: "2월 12일" },
                                { label: "화", date: "2월 13일" },
                                { label: "수", date: "2월 14일" },
                                { label: "목", date: "2월 15일" },
                                { label: "금", date: "2월 16일" }
                            ],
                            participants: [
                                { name: "지수", id: 1 },
                                { name: "민구", id: 2 },
                                { name: "성문", id: 3 },
                                { name: "아현", id: 4 },
                                { name: "민지", id: 5 },
                                { name: "하니", id: 6 },
                                { name: "혜인", id: 7 },
                                { name: "다니엘", id: 8 },
                                { name: "혜린", id: 9 },
                                { name: "한국", id: 10 },
                                { name: "지헌", id: 11 },
                                { name: "하루", id: 12 }
                            ],
                            // 가용성 데이터를 셀 색상 정보로 변환
                            availabilityColors: {}
                        };
                        
                        // 각 날짜별, 시간별 참여자 가용성 데이터
                        const availability = {
                            "월_11:00": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], // 모두 참여 가능
                            "월_11:15": [1, 2, 3, 8, 9, 10, 11, 12],    // 8명 참여 가능
                            "월_11:30": [2, 3, 4, 5, 6],       // 5명 참여 가능
                            "월_11:45": [4, 7, 9],          // 3명만 참여 가능
                            "월_12:00": [1, 2, 4, 7, 8, 9],
                            "월_13:30": [1, 3, 4, 5, 11, 12],
                            "화_11:00": [1, 2, 7, 8, 9, 10],
                            "화_11:15": [2, 3, 4, 5, 6, 7, 8],
                            "화_14:00": [1, 2, 3, 4, 5, 6, 7, 8, 9],
                            "수_11:00": [3, 4, 10, 11, 12],
                            "수_13:00": [1, 2, 3, 5, 6, 7],
                            "목_11:45": [1, 4, 5, 6, 8, 9, 10],
                            "목_15:00": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
                            "금_11:30": [2, 3, 4, 7, 8, 9, 10],
                            "금_11:45": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
                        };
                        
                        // 가용성 데이터를 셀 색상으로 변환
                        const totalParticipants = data.participants.length;
                        
                        // 각 셀 데이터 색상 및 정보 생성
                        for (let day of data.days) {
                            let currentHour = 9;  // 시작 시간(9시)
                            let currentMinute = 0;
                            
                            while (currentHour < 16 || (currentHour === 16 && currentMinute === 0)) {
                                // 시간 형식 포맷팅
                                const formattedHour = currentHour.toString().padStart(2, '0');
                                const formattedMinute = currentMinute.toString().padStart(2, '0');
                                const formattedTime = `${formattedHour}:${formattedMinute}`;
                                
                                // 가용성 키 생성 (요일_시간)
                                const availabilityKey = `${day.label}_${formattedTime}`;
                                const availableUsers = availability[availabilityKey] || [];
                                
                                if (availableUsers.length > 0) {
                                    // 참여 가능한 사람 비율 계산
                                    const ratio = availableUsers.length / totalParticipants;
                                    
                                    // HSL 색상 계산 - 보라색(270) 유지하되 광도 조정
                                    const saturation = 70 + (30 * ratio); 
                                    // 가장 진한 색의 광도 늘림 (최소값 45%로 변경)
                                    const lightness = 90 - (45 * ratio);
                                    
                                    // 셀 키 생성
                                    const cellKey = `${day.label}_${formattedTime}`;
                                    
                                    // 배경색 설정 및 텍스트 색상 정보 추가
                                    data.availabilityColors[cellKey] = {
                                        backgroundColor: `hsl(270, ${saturation}%, ${lightness}%)`,
                                        title: `참여 가능: ${availableUsers.length}/${totalParticipants}`,
                                        participantIds: availableUsers,
                                        // 텍스트 색상 정보 추가 (어두운 셀에만 흰색 적용)
                                        textColor: ratio > 0.5 ? 'white' : 'black'
                                    };
                                }
                                
                                // 다음 시간대로 이동
                                currentMinute += data.interval;
                                if (currentMinute >= 60) {
                                    currentHour += Math.floor(currentMinute / 60);
                                    currentMinute %= 60;
                                }
                            }
                        }
                        
                        // 데이터 설정
                        window.jsonData = data;
                        
                        // 로더 숨기기
                        document.getElementById('scheduleLoader').classList.add('hidden');
                        
                        // 일정 정보 표시 영역 추가
                        if (!document.getElementById('selectedCellInfo')) {
                            const infoDiv = document.createElement('div');
                            infoDiv.id = 'selectedCellInfo';
                            infoDiv.className = 'mt-4 p-6 bg-white rounded-lg shadow text-center border-2 border-purple-300 border-dashed flex items-center justify-center min-h-[120px]';
                            infoDiv.innerHTML = `
                                <div class="text-gray-500 text-md">
                                    <i class="fas fa-info-circle text-purple-500 mr-2"></i>
                                    선택된 셀이 없어요. 셀을 선택하시면 가능한 인원이 여기에 표시돼요.
                                </div>
                            `;
                            document.getElementById('app').insertAdjacentElement('afterend', infoDiv);
                        }
                        
                        // 전역 변수 명시적 초기화 (window 객체에 추가)
                        window.currentPage = 0;
                        window.itemsPerPage = window.innerWidth <= 629 ? 3 : 5;
                        console.log(`초기화: 페이지=${window.currentPage}, 항목수=${window.itemsPerPage}`);
                        
                        // 스케줄 업데이트 (자체적으로 페이지네이션 처리)
                        window.updateSchedule();
                        
                        // 셀에 색상 적용 및 툴팁 추가
                        setTimeout(applyAvailabilityColors, 100);
                        
                    } catch (error) {
                        console.error('일정 데이터를 가져오는 중 오류 발생:', error);
                        
                        // 간단한 오류 대체 데이터
                            window.jsonData = {
                                startTime: "09:00",
                                endTime: "16:00",
                                interval: 15,
                                days: [
                                { label: "월", date: "2월 12일" },
                                { label: "화", date: "2월 13일" },
                                { label: "수", date: "2월 14일" }
                            ],
                            participants: [
                                { name: "지수", id: 1 },
                                { name: "민구", id: 2 }
                                ]
                            };
                            
                            // 로더 숨기기
                            document.getElementById('scheduleLoader').classList.add('hidden');
                            
                            // 스케줄 업데이트
                            window.updateSchedule();
                    }
                }
                
                // 생성된 셀에 가용성 색상 적용 및 툴팁, 클릭 이벤트 추가
                function applyAvailabilityColors() {
                    if (!window.jsonData || !window.jsonData.availabilityColors) return;
                    
                    const colors = window.jsonData.availabilityColors;
                    const participants = window.jsonData.participants || [];
                    
                    // 현재 표시 중인 날짜 배열 계산
                    const startIndex = window.currentPage * window.itemsPerPage;
                    const endIndex = startIndex + window.itemsPerPage;
                    const currentPageDays = window.jsonData.days.slice(startIndex, endIndex);
                    
                    console.log(`현재 표시 중인 날짜: ${JSON.stringify(currentPageDays.map(d => d.date))}`);
                    
                    document.querySelectorAll('.grid-cell').forEach((cell, cellIndex) => {
                        // 시간 열 제외
                        const dayIndex = Array.from(cell.parentNode.children).indexOf(cell) - 1;
                        if (dayIndex < 0) return;
                        
                        const rowParent = cell.closest('div[class*="grid-cols-"]') || cell.parentNode;
                        
                        // 현재 표시 중인 페이지에서의 요일 인덱스
                        if (dayIndex >= currentPageDays.length) return;
                        
                        // 현재 페이지의 요일 정보
                        const day = currentPageDays[dayIndex].label;
                        
                        // 시간 계산
                        const rowIndex = Math.floor(Array.from(rowParent.parentNode.children).indexOf(rowParent));
                        const startTimeObj = parseTimeString(window.jsonData.startTime);
                        const startTotalMin = toTotalMinutes(startTimeObj.hour, startTimeObj.minute);
                        const timeOffset = rowIndex * window.jsonData.interval;
                        const cellTimeMinutes = startTotalMin + timeOffset;
                        const formattedTime = formatTime24(cellTimeMinutes);
                        
                        // 셀 키 생성
                        const cellKey = `${day}_${formattedTime}`;
                        
                        console.log(`셀 키 생성: ${cellKey}, 요일=${day}, 시간=${formattedTime}`);
                        
                        // 가용성 색상 정보가 있으면 적용
                        if (colors[cellKey]) {
                            cell.style.backgroundColor = colors[cellKey].backgroundColor;
                            
                            // 참여자 수 표시
                            const participantIds = colors[cellKey].participantIds || [];
                            
                            // 기존 텍스트 제거
                            const existingText = cell.querySelector('span');
                            if (existingText) {
                                cell.removeChild(existingText);
                            }
                            
                            const countText = document.createElement('span');
                            countText.className = 'text-xs font-medium text-white';
                            countText.textContent = `${participantIds.length}/${participants.length}`;
                            cell.appendChild(countText);
                            
                            // 툴팁에 참여자 이름 추가
                            if (participantIds.length > 0) {
                                const names = participantIds.map(id => {
                                    const participant = participants.find(p => p.id === id);
                                    return participant ? participant.name : "알 수 없음";
                                });
                                
                                // 종료 시간 계산 (15분 후)
                                const endTime = calculateEndTime(formattedTime, 15);
                                const timeRange = `${formattedTime}-${endTime}`;
                                
                                let tooltipText;
                                if (names.length <= 3) {
                                    tooltipText = `${timeRange} 참여 가능: ${names.join(", ")}`;
                                } else {
                                    tooltipText = `${timeRange} 참여 가능: ${names.slice(0, 3).join(", ")} 외 ${names.length - 3}명`;
                                }
                                
                                cell.title = tooltipText;
                                
                                // 데이터 속성에 모든 정보 저장
                                cell.dataset.day = day;
                                cell.dataset.time = formattedTime;
                                cell.dataset.participantIds = JSON.stringify(participantIds);
                                
                                // 클릭 이벤트 추가
                                cell.addEventListener('click', function() {
                                    showParticipantInfo(this);
                                });
                            }
                        } else {
                            // 색상 정보가 없으면 기본 배경색 적용
                            cell.style.backgroundColor = "rgb(229, 231, 235)"; // bg-gray-200
                            
                            // 기존 텍스트와 정보 제거
                            const existingText = cell.querySelector('span');
                            if (existingText) {
                                cell.removeChild(existingText);
                            }
                            
                            // 데이터 속성 초기화
                            cell.dataset.day = "";
                            cell.dataset.time = "";
                            cell.dataset.participantIds = "[]";
                            
                            // 이벤트 리스너도 제거
                            cell.replaceWith(cell.cloneNode(true));
                        }
                    });
                }
                
                // 셀 클릭 시 참여자 정보 표시
                function showParticipantInfo(cell) {
                    const infoDiv = document.getElementById('selectedCellInfo');
                    if (!infoDiv) return;
                    
                    // 먼저 모든 셀의 스타일을 초기화
                    document.querySelectorAll('.grid-cell').forEach(cell => {
                        // 모든 추가 스타일 속성 제거
                        cell.style.boxShadow = '';
                        cell.style.borderRadius = '';
                        cell.style.position = '';
                        cell.style.zIndex = '';
                        cell.classList.remove('selected');
                    });
                    
                    // 선택된 셀에 강조 효과 적용
                    cell.classList.add('selected');
                    
                    // 내부 테두리 효과는 유지하고 외부 그림자만 제거
                    cell.style.boxShadow = `inset 0 0 0 3px #40A9FF`; // 내부 테두리 효과만 유지 (파란색)
                    
                    cell.style.borderRadius = '6px'; // 둥근 테두리 효과
                    cell.style.position = 'relative'; // 상대적 위치 설정
                    cell.style.zIndex = '2';
                    
                    // 셀 데이터 추출
                    const day = cell.dataset.day;
                    const time = cell.dataset.time;
                    const participantIds = JSON.parse(cell.dataset.participantIds || '[]');
                    
                    // 종료 시간 계산 (15분 후)
                    const endTime = calculateEndTime(time, 15);
                    const timeRange = `${time}-${endTime}`;
                    
                    if (participantIds.length === 0) {
                        infoDiv.innerHTML = '<p class="text-gray-500">이 시간에는 참여 가능한 인원이 없습니다.</p>';
                        infoDiv.className = 'mt-4 p-6 bg-white rounded-lg shadow text-left';
                        return;
                    }
                    
                    // 참여자 정보 구성
                    const participants = window.jsonData.participants || [];
                    const participantInfos = participantIds.map(id => {
                        const participant = participants.find(p => p.id === id);
                        return participant ? participant.name : "알 수 없음";
                    });
                    
                    // HTML 구성 수정
                    let html = `
                        <h3 class="font-bold text-lg text-purple-800">${day}요일 ${timeRange}</h3>
                        <p class="mb-2 text-purple-600">참여 가능한 인원: ${participantIds.length}명</p>
                        <div class="flex flex-wrap gap-2">
                    `;
                    
                    // 참여자 태그 스타일 수정
                    participantInfos.forEach(name => {
                        html += `
                            <span class="bg-purple-100 text-purple-800 px-2 py-1 rounded-full text-sm font-medium">
                                ${name}
                            </span>
                        `;
                    });
                    
                    html += `</div>`;
                    
                    // 정보 표시
                    infoDiv.innerHTML = html;
                    infoDiv.className = 'mt-4 p-6 bg-white rounded-lg shadow text-left';
                    
                    // 스타일 강제 적용
                    const titleEl = infoDiv.querySelector('h3');
                    const countEl = infoDiv.querySelector('p');
                    const nameEls = infoDiv.querySelectorAll('span');
                    
                    if (titleEl) titleEl.style.color = '#6B46C1';  // purple-800
                    if (countEl) countEl.style.color = '#7C3AED';  // purple-600
                    nameEls.forEach(el => {
                        el.style.backgroundColor = '#F3E8FF';  // purple-100
                        el.style.color = '#6B46C1';  // purple-800
                    });
                }
                
                // 종료 시간 계산 함수 (시작 시간에서 minutes 분 후)
                function calculateEndTime(startTime, minutes) {
                    const [hours, mins] = startTime.split(':').map(Number);
                    
                    // 분 단위로 변환하고 minutes를 더한 다음 다시 시간과 분으로 변환
                    let totalMinutes = hours * 60 + mins + minutes;
                    const newHours = Math.floor(totalMinutes / 60);
                    const newMins = totalMinutes % 60;
                    
                    // 시간과 분을 두 자리 문자열로 포맷팅
                    const formattedHours = newHours.toString().padStart(2, '0');
                    const formattedMins = newMins.toString().padStart(2, '0');
                    
                    return `${formattedHours}:${formattedMins}`;
                }
                
                // 시간 관련 유틸리티 함수
                function parseTimeString(str) {
                    const [hh, mm] = str.split(":");
                    return { hour: parseInt(hh, 10), minute: parseInt(mm, 10) };
                }
                
                function toTotalMinutes(h, m) {
                    return h * 60 + m;
                }
                
                function formatTime24(totalMin) {
                    const h = Math.floor(totalMin / 60);
                    const min = totalMin % 60;
                    const hh = h < 10 ? "0" + h : "" + h;
                    const mm = min < 10 ? "0" + min : "" + min;
                    return `${hh}:${mm}`;
                }
                
                // 페이지네이션 관련 코드를 완전히 재작성합니다
                function updatePagination() {
                    console.log(`페이지네이션 업데이트: 현재 페이지=${window.currentPage}`);
                    
                    // 현재 페이지에 표시할 날짜 계산
                    const startIndex = window.currentPage * window.itemsPerPage;
                    const currentPageDays = window.jsonData.days.slice(startIndex, startIndex + window.itemsPerPage);
                    
                    console.log(`현재 페이지 날짜:`, currentPageDays.map(d => d.date));
                    
                    // 사용자 정의 데이터로 스케줄 업데이트
                    const scheduleData = {
                        ...window.jsonData,
                        days: currentPageDays,
                        startIndex: startIndex,
                        totalDays: window.jsonData.days.length
                    };
                    
                    // 스케줄 테이블 새로 렌더링
                    const app = document.getElementById("app");
                    
                    // 날짜 헤더 생성
                    let dayHeaderHtml = `
                        <div class="flex mb-2">
                            <div class="w-16 mr-2"></div>
                            <div class="flex-1">
                                <div class="grid" style="grid-template-columns: repeat(${currentPageDays.length}, 1fr)">
                                    ${currentPageDays.map((d, index) => `
                                        <div class="text-center" 
                                             style="${index !== currentPageDays.length - 1 ? 'border-right: 1px solid #d1d5db;' : ''}">
                                            <div class="text-sm text-gray-500">${d.label}요일</div>
                                            <div class="text-lg font-semibold">${d.date}</div>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        </div>
                    `;
                    
                    // 시간표 HTML 생성
                    const tableHTML = buildScheduleTable(scheduleData);
                    
                    // 앱 컨테이너 업데이트
                    app.innerHTML = dayHeaderHtml + tableHTML;
                    
                    // 페이지 버튼 추가
                    setTimeout(() => {
                        const gridContainer = document.querySelector('.flex-1.relative');
                        if (!gridContainer) return;
                        
                        // 기존 버튼 제거
                        const existingPrevBtn = document.getElementById('prevPage');
                        const existingNextBtn = document.getElementById('nextPage');
                        if (existingPrevBtn) existingPrevBtn.remove();
                        if (existingNextBtn) existingNextBtn.remove();
                        
                        // 이전 페이지 버튼
                        if (window.currentPage > 0) {
                            const btnPrev = document.createElement('button');
                            btnPrev.id = 'prevPage';
                            btnPrev.className = 'absolute left-[-20px] top-1/2 transform -translate-y-1/2 page-button';
                            btnPrev.innerHTML = '←';
                            btnPrev.onclick = function() {
                                window.currentPage--;
                                console.log('이전 페이지로 이동:', window.currentPage);
                                updatePagination();
                                setTimeout(() => {
                                    adjustTimeBarPositions(window.jsonData.interval);
                                    applyAvailabilityColors();
                                }, 100);
                            };
                            gridContainer.appendChild(btnPrev);
                        }
                        
                        // 최대 페이지 계산
                        const maxPage = Math.ceil(window.jsonData.days.length / window.itemsPerPage) - 1;
                        
                        // 다음 페이지 버튼
                        if (window.currentPage < maxPage) {
                            const btnNext = document.createElement('button');
                            btnNext.id = 'nextPage';
                            btnNext.className = 'absolute right-[-20px] top-1/2 transform -translate-y-1/2 page-button';
                            btnNext.innerHTML = '→';
                            btnNext.onclick = function() {
                                window.currentPage++;
                                console.log('다음 페이지로 이동:', window.currentPage);
                                
                                // 디버깅: 현재 페이지에 표시될 날짜 출력
                                const startIndex = window.currentPage * window.itemsPerPage;
                                const debugDays = window.jsonData.days.slice(startIndex, startIndex + window.itemsPerPage);
                                console.log('현재 페이지 날짜:', debugDays.map(d => d.label));
                                console.log('가용성 데이터 키:', Object.keys(window.jsonData.availabilityColors));
                                
                                updatePagination();
                                setTimeout(() => {
                                    adjustTimeBarPositions(window.jsonData.interval);
                                    applyAvailabilityColors();
                                    
                                    // 디버깅: 실제 표시된 셀 정보 확인
                                    console.log('표시된 셀 수:', document.querySelectorAll('.grid-cell').length);
                                    document.querySelectorAll('.grid-cell[data-day="목"]').forEach(cell => {
                                        console.log('목요일 셀:', cell.dataset.time, cell.style.backgroundColor);
                                    });
                                }, 100);
                            };
                            gridContainer.appendChild(btnNext);
                        }
                    }, 0);
                    
                    // 시간바 위치 조정
                    setTimeout(() => {
                        adjustTimeBarPositions(window.jsonData.interval);
                        applyAvailabilityColors();
                    }, 100);
                }
                
                // 기존 updateSchedule 함수 완전 대체
                const originalUpdateSchedule = window.updateSchedule;
                window.updateSchedule = function() {
                    // 페이지네이션 업데이트 함수 호출
                    updatePagination();
                    return true;
                };
                
                // 페이지 로드 및 리사이징 코드는 기존 코드 유지
                document.addEventListener("DOMContentLoaded", function () {
                    fetchScheduleData();
                    
                    window.addEventListener("resize", function () {
                        const newItemsPerPage = window.innerWidth <= 629 ? 3 : 5;
                        if (newItemsPerPage !== window.itemsPerPage) {
                            window.itemsPerPage = newItemsPerPage;
                            window.currentPage = 0;  // 리사이징 시 첫 페이지로 초기화
                            window.updateSchedule();
                        }
                    });
                });
            </script>
            <!-- 버튼 그룹 -->
            <div class="flex flex-col sm:flex-row justify-center gap-4 md-[30px] mt-[15px]">
                <button id="shareButton" class="bg-purple-700 text-white btn-responsive-font py-2 font-bold px-6 rounded hover:bg-purple-700 transition-colors">
                    공유하기
                </button>

                <button class="bg-[#FEE500] text-[#191919] btn-responsive-font py-2 px-6 font-bold rounded hover:bg-[#FEE500] transition-colors" id="kakao-login" onclick="redirectKakao()">
                    카카오로 로그인하고 내 일정 등록하기
                </button>

                <button class="bg-purple-700 text-white btn-responsive-font py-2 font-bold px-6 rounded hover:bg-purple-700 transition-colors" id="kakao-calendar-auth" >
                    내 일정 등록하기
                </button>

                <button class="bg-[#FEE500] text-[#191919] btn-responsive-font py-2 px-6 font-bold rounded hover:bg-[#FEE500] transition-colors" id="kakao-calendar" onclick="window.location.href = '/test/token'">
                    톡캘린더
                </button>

            </div>


        </div>
    </div>
</main>

<footer class="bg-purple-800 text-white py-6">
    <div class="container mx-auto text-center">
        <p class="text-sm">&copy; Made with 💜 by 퍼플코드랩스</p>
    </div>
</footer>

<script>




function redirectKakao() {
const clientId = "e6c0d0aedffcb33efa50bd47deba9e3d"; // 카카오 REST API 키
const redirectUri = encodeURIComponent("https://localhost:443/oauth/kakao/callback");
const kakaoAuthUrl =
`https://kauth.kakao.com/oauth/authorize?client_id=${clientId}&redirect_uri=${redirectUri}&response_type=code&scope=friends,profile_image,profile_nickname,talk_calendar,talk_message`;

window.location.href = kakaoAuthUrl;
}

document.addEventListener('DOMContentLoaded', function() {
    // 페이지가 로드된 후 잠시 지연을 주어 스크롤 이동
    setTimeout(function() {
        window.scrollTo(0, 0); // 스크롤을 최상단으로
    }, 100); // 100ms 정도 지연시켜줌으로써 페이지 레이아웃 안정화 후 실행
});

document.getElementById("shareButton").addEventListener("click", async () => {
    try {
        // 현재 URL을 공유 URL로 사용
        const currentUrl = window.location.href;
        
        await navigator.share({
            title: 'OverLap 일정 공유 테스트', // JSON에서 받아온 title 사용
            text: 'OverLap에서 생성한 일정입니다.',
            url: currentUrl,
        });
        console.log('공유 성공');
    } catch (e) {
        console.log('공유 실패');
    }
});

</script>
</body>
</html>

