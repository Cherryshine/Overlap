<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
  <title>OverLap - 메인 랜딩페이지</title>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet"/>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet"/>
  <link href="https://ai-public.creatie.ai/gen_page/tailwind-custom.css" rel="stylesheet"/>

  <script src="https://cdn.tailwindcss.com/3.4.5?plugins=forms@0.5.7,typography@0.5.13,aspect-ratio@0.4.2,container-queries@0.1.1"></script>
  <script src="https://ai-public.creatie.ai/gen_page/tailwind-config.min.js" data-color="#000000" data-border-radius="small"></script>
  <style>
    .glass-effect {
      background: rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 1rem; /* 동일한 곡률을 적용 */
    }
    @keyframes float {
      0% { transform: translateY(0); }
      50% { transform: translateY(-2px); }
      100% { transform: translateY(0); }
    }
    .logo-animation {
      animation: float 2s ease-in-out infinite;
    }
    .full-screen {
      min-height: 100vh;
    }
    .chat-message {
      opacity: 0;
      transform: translateY(20px);
      transition: opacity 0.7s ease, transform 0.7s ease;
    }
    @keyframes expand {
      0% {
        opacity: 0;
        transform: scale(0.5);
      }
      100% {
        opacity: 1;
        transform: scale(1);
      }
    }
    .animate-expand {
      animation: expand 0.6s ease-out;
      transform-origin: top;
    }

    /* 버튼 애니메이션 */
    .btn-animate {
      opacity: 0;
      transform: translateY(20px);
      transition: opacity 0.7s ease, transform 0.7s ease;
    }
    .btn-show {
      opacity: 1;
      transform: translateY(0);
    }

    /* 전체 레이아웃을 flex로 설정하여 푸터를 하단에 고정 */
    body, html {
      height: auto;  /* 고정 높이 대신 자동으로 조정 */
      margin: 0;
      display: flex;
      flex-direction: column;
    }

    .content {
      flex-grow: 1;
    }

    footer {
      margin-top: auto; /* 푸터를 하단에 고정 */
    }

    /* 커스텀 드롭다운 */
    .custom-dropdown {
      position: relative;
      width: 100%; /* 드롭다운 전체가 가로폭을 100% 차지하도록 설정 */
    }

    .dropdown-menu {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      z-index: 10;
      display: none;
      background-color: #f4eeff;
      border-radius: 0;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
      max-height: 300px;
      overflow-y: auto;
      border-radius: 5px;
      border: 1px solid #ddd;
    }

    .dropdown-menu.show {
      display: block;
    }

    .dropdown-menu a:active,
    .dropdown-menu a:focus {
      background-color: #8b5cf6; /* 보라색 */
      color: white; /* 글자 색을 흰색으로 변경 */
    }

    /* 선택된 항목에 보라색 배경 추가 */
    .dropdown-menu a.selected {
      background-color: #8b5cf6; /* 보라색 */
      color: white; /* 글자 색을 흰색으로 변경 */
    }

    .dropdown-menu a {
      display: block;
      padding: 8px 16px;
      color: #866198;
      text-decoration: none;
      cursor: pointer;
      border-bottom: 0.5px solid #b3a6b9; /* 항목 사이에 구분선 추가 */
    }

    .dropdown-menu a:last-child {
      border-bottom: none; /* 마지막 항목은 구분선이 없도록 설정 */
    }

    .dropdown-menu a:hover {
      background-color: #aa8eec;
      color: white;
    }

    .dropdown-wrapper {
      display: flex;
      align-items: center; /* 수직 중앙 정렬 */
      width: 100%;
      min-width: 280px; /* 드롭다운의 최소 너비 */
      margin-bottom: 10px;
    }

    .dropdown-wrapper > .custom-dropdown {
      flex: 1 1 0%; /* 드롭다운들이 동일한 크기로 분배됨 */
    }

    .dropdown-wrapper > .text-between {
      display: flex;
      align-items: center;
      justify-content: center;
      width: auto; /* "부터" 텍스트가 가운데 위치하도록 */
      font-size: 16px;
      color: #650094;
      margin: 0 10px; /* 좌우 간격 추가 */
    }

    /* 드롭다운과 "부터" 텍스트 사이의 간격을 조정 */
    .dropdown-wrapper > .custom-dropdown:last-child {
      margin-right: 0; /* 마지막 드롭다운은 오른쪽 여백 없애기 */
    }

    .custom-dropdown button {
      display: flex;
      justify-content: space-between;
      align-items: center;
      white-space: nowrap; /* 텍스트 줄바꿈 방지 */
      overflow: hidden; /* 넘치는 텍스트 숨김 */
      text-overflow: ellipsis; /* 넘치는 텍스트를 ...으로 표시 */
    }

    /* 그라데이션 배경 설정 */
    body {
      background-size: 100% auto;  /* 너비 100%, 높이는 자동으로 조정 */
      background-repeat: no-repeat;
      min-height: 100%;  /* 최소 높이를 100%로 설정 */
    }

    /*
    캘린더
     */

    #calendar {
      width: 100%;
      background-color: #fff;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      padding: 20px;
      margin-bottom: 5px !important;
      overflow: hidden;
    }

    #calendar table {
      width: 100%;
      border-collapse: separate;
      border-spacing: 2px;
      table-layout: fixed;
    }

    #calendar thead {
      border-bottom: 2px solid #8b5cf6; /* 보라색 구분선 추가 */
    }

    #calendar th {
      padding: 8px 0;
      font-weight: 600;
      border-bottom: 2px solid #8b5cf6; /* 보라색 구분선 추가 */
      margin-bottom: 8px; /* 구분선과 날짜 사이 여백 */
    }

    #calendar td {
      width: calc(100% / 7); /* 7일로 균등 분할 */
      position: relative;
      text-align: center;
      vertical-align: middle;
    }

    /* td에 정사각형 비율 유지 */
    #calendar td::before {
      content: '';
      display: block;
      padding-top: 100%; /* 1:1 비율 유지 */
    }

    #calendar td > * {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* 반응형 스타일 수정 */
    @media screen and (max-width: 360px) {
      #calendar {
        padding: 0.5rem;
        margin-bottom: 0.5rem;
      }

      #calendar table {
        border-spacing: 1px;
      }

      #calendar th {
        padding: 6px 0;
        border-bottom-width: 1px; /* 작은 화면에서는 더 얇은 선 */
      }

      #calendar td {
        font-size: 0.7rem;
      }

      .calendar-nav {
        margin-bottom: 0.5rem;
        gap: 4px;
      }

      .calendar-nav button {
        padding: 4px 8px;
        font-size: 0.75rem;
      }

      .calendar-nav span {
        font-size: 0.9rem;
      }
    }

    @media screen and (min-width: 361px) and (max-width: 480px) {
      #calendar {
        padding: 0.75rem;
      }

      #calendar table {
        border-spacing: 1.5px;
      }

      #calendar th {
        padding: 7px 0;
        border-bottom-width: 1.5px; /* 중간 크기 화면에서는 중간 두께의 선 */
      }

      #calendar td {
        font-size: 0.8rem;
      }

      .calendar-nav {
        margin-bottom: 0.75rem;
        gap: 6px;
      }

      .calendar-nav button {
        padding: 5px 10px;
        font-size: 0.85rem;
      }

      .calendar-nav span {
        font-size: 1rem;
      }
    }

    /* 캘린더 셀 스타일 수정 */
    #calendar td.day {
      cursor: pointer;
      transition: background-color 0.2s;
      -webkit-tap-highlight-color: transparent; /* 모바일 터치 시 기본 하이라이트 제거 */
    }

    /* 호버 효과를 데스크톱에서만 적용 */
    @media (hover: hover) and (pointer: fine) {
      #calendar td.day:hover {
        background-color: #aa8eec;
        color: white;
        border-radius: 4px;
      }
    }

    /* 터치 디바이스를 위한 활성 상태 스타일 */
    #calendar td.day:active {
      background-color: #aa8eec;
      color: white;
      border-radius: 4px;
    }

    /* 선택된 날짜 스타일 */
    #calendar td.selected {
      background-color: #8b5cf6;
      color: white;
      border-radius: 4px;
    }

    /* 오늘 날짜 스타일 */
    #calendar td.today {
      border: 2px solid #8b5cf6;
      border-radius: 4px;
    }

    /* 달력 네비게이션 */
    .calendar-nav {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 8px;
      margin-bottom: 1rem;
      position: relative;
    }

    /* 월 이동 버튼 컨테이너 */
    .month-nav {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    /* 오늘 버튼 위치 조정 */
    #todayBtn {
      position: relative;
      margin: 15px auto 5px; /* 하단 여백 추가 */
      background-color: #e1bee7;
      color: #4a148c;
      padding: 6px 12px;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
      width: fit-content;
      z-index: 1; /* 버튼이 다른 요소들 위에 표시되도록 */
    }

    #todayBtn svg {
      width: 16px;
      height: 16px;
    }

    #todayBtn svg rect { /* circle을 rect로 변경 */
      fill: none;
      stroke: #4a148c;
      stroke-width: 2;
    }

    /* #todayBtn:hover {
      background-color: #d1aee7;
    } */

    /* 작은 화면에서 오늘 버튼 스타일 */
    @media screen and (max-width: 360px) {
      #calendar {
        padding-bottom: 45px; /* 캘린더 하단 패딩 증가 */
      }

      #todayBtn {
        margin: 10px auto 0;
        padding: 4px 8px;
        font-size: 0.8rem;
      }
    }

    @media screen and (min-width: 361px) and (max-width: 480px) {
      #calendar {
        padding-bottom: 50px; /* 캘린더 하단 패딩 증가 */
      }

      #todayBtn {
        margin: 12px auto 0;
        padding: 5px 10px;
        font-size: 0.85rem;
      }
    }

    /* 컨테이너 최소 너비 설정 */
    .container {
      min-width: 320px; /* 모바일 기기의 일반적인 최소 너비 */
    }

    /* 작은 화면을 위한 반응형 스타일 */
    @media screen and (max-width: 372px) {
      /* 드롭다운 컨테이너를 세로로 재배치 */
      .dropdown-wrapper {
        flex-direction: column;
        align-items: center;
        gap: 10px;
      }
      /* 드롭다운 버튼은 전체 너비로 적용하고, margin-top을 무조건 제거 */
      .dropdown-wrapper > .custom-dropdown {
        width: 100%;
        margin-top: 0 !important;
      }
      /* 특히 #dropdownMenu2Button 에는 margin-top 제거를 확실히 적용 */
      #dropdownMenu2Button {
        margin-top: 0 !important;
      }
      /* '부터' 텍스트는 한 줄(가로)로 유지 */
      .dropdown-wrapper > .text-between {
        white-space: nowrap;
        margin: 10px 0;
      }
    }

    /* 중간 크기 화면을 위한 추가 브레이크포인트 */
    @media screen and (min-width: 361px) and (max-width: 480px) {
      .content {
        padding: 0.75rem;
      }

      .glass-effect {
        padding: 1.5rem;
      }

      .dropdown-wrapper {
        min-width: 100%;
      }

      #calendar {
        padding: 1rem;
      }

      #calendar th,
      #calendar td {
        font-size: 0.875rem;
      }
    }

    /* 드롭다운 메뉴가 화면을 벗어나지 않도록 처리 */
    .dropdown-menu {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      max-width: 100%;
      width: 100%;
    }

    /* 모바일에서 터치 영역 개선 */
    .custom-dropdown button,
    .dropdown-menu a,
    #nextButton {
      min-height: 44px; /* iOS 권장 최소 터치 영역 */
    }

    /* 캘린더 셀 터치 영역 개선 */
    #calendar td.day {
      min-width: 32px;
      min-height: 32px;
    }

    /* 작은 화면에서의 드롭다운 스타일 */
    @media screen and (max-width: 480px) {
      .custom-dropdown button {
        font-size: 0.9rem; /* 글자 크기 축소 */
        padding: 8px; /* 패딩 축소 */
      }

      .dropdown-wrapper {
        min-width: 100%;
      }
    }

    @media screen and (max-width: 360px) {
      .custom-dropdown button {
        font-size: 0.8rem; /* 더 작은 화면에서는 글자 크기를 더 축소 */
        padding: 6px; /* 패딩을 더 축소 */
      }
    }

    /* 일요일 색상 */
    #calendar th:first-child,
    #calendar td:first-child {
      color: #e53935; /* 빨간색 */
    }

    /* 토요일 색상 */
    #calendar th:last-child,
    #calendar td:last-child {
      color: #1976d2; /* 파란색 */
    }

    /* 선택된 날짜는 글자색 흰색 유지 */
    #calendar td.selected {
      background-color: #8b5cf6;
      color: white !important; /* !important로 토/일요일 색상 오버라이드 */
      border-radius: 4px;
    }

    /* 호버 상태에서도 글자색 흰색 유지 */
    @media (hover: hover) and (pointer: fine) {
      #calendar td.day:hover {
        background-color: #aa8eec;
        color: white !important;
        border-radius: 4px;
      }
    }

    /* 터치 활성 상태에서도 글자색 흰색 유지 */
    #calendar td.touch-active {
      background-color: #aa8eec;
      color: white !important;
      border-radius: 4px;
    }

    /* 말풍선(툴크 네모 영역 */
    #dateHelpTooltip {
      position: absolute;
      background: white;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
      border-radius: 8px;
      font-size: 0.875rem;
      line-height: 1.5;
      margin-left: 20px;
      padding: 8px 16px;
      text-align: left;
      white-space: nowrap;
      z-index: 1000;
      top: calc(100% + 10px); /* 아이콘 아래 10px 간격 */
      /* transform 제거 – 좌측 위치는 JS에서 직접 처리 */
    }

    /* 말풍선 꼭짓점(마름모)
       - tooltip 네모의 우측 상단에 위치하며, 오른쪽 offset은 CSS 변수(--diamond-offset)로 지정 */
    #dateHelpTooltip::before {
      content: '';
      position: absolute;
      top: -6px; /* 툴크 상단에서 6px 위 */
      right: var(--diamond-offset, 10px); /* JS에서 계산한 값을 사용 (기본: 10px) */
      transform: rotate(45deg);
      margin-right: 20px;
      width: 12px;
      height: 12px;
      background: white;
      box-shadow: -3px -3px 5px rgba(0,0,0,0.1);
    }

    /* 좌우 흔들림 애니메이션 정의 */
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-5px); }
      75% { transform: translateX(5px); }
    }

    /* 흔들림 효과를 적용할 클래스 */
    .shake-error {
      animation: shake 0.2s ease-in-out;
      animation-iteration-count: 2;
    }

    /* 날짜 숫자 스타일: 기본 옅은 회색 */
    .circle {
      color: inherit;
    }

    /* 오늘보다 이전 날짜 (disabled 된 날짜)의 숫자만 옅은 회색으로 표기 */
    #calendar td.day.disabled .circle {
      color: #ccc;
    }

    /* 오늘 이전 날짜 비활성화: 클릭·드래그 불가, 살짝 불투명하게 처리 */
    #calendar td.day.disabled {
      pointer-events: none;
      opacity: 0.6;
    }

    /* 에러 메시지가 나타날 경우, inline 스타일을 override하여 레이아웃에 영향을 주지 않도록 처리 */
    .custom-dropdown > #startDropdownError,
    .custom-dropdown > #endDropdownError {
      position: absolute !important;
      top: calc(100% + 4px) !important; /* 버튼 바로 아래에 위치 (원하는 간격: 4px) */
      left: 0;
      width: 100%;
      margin: 0 !important;
      padding: 0;
      font-size: 0.75em;
      color: #d32f2f;
      z-index: 10;
    }

    #titleError {
      margin-top: 5px !important;
    }
  </style>
</head>
<body class="bg-gradient-to-br from-purple-200 via-purple-300 to-purple-400">

<div th:replace="~{/nav :: nav}"></div>

<div class="container mx-auto px-4 sm:px-6 md:px-8 lg:px-[60px] pt-[84px] sm:pt-[150px] pb-[50px] min-h-[calc(100vh-80px)] max-w-4xl content">
  <!-- 컨테이너 내부 내용 제거됨 -->
  <div class="glass-effect rounded-3xl p-8">
    <p class="text-purple-800 font-bold mb-[15px] text-2xl">새 일정 만들기</p>
    <input type="text" id="titleInput" class="w-full bg-white bg-opacity-20 border-0 rounded-lg p-3 text-purple-800 mt-[10px] placeholder-purple-800" placeholder="일정 제목을 입력하세요" required/>

    <!-- 선택된 날짜 표시 영역 추가 -->
    <div id="selectedDatesContainer" class="mt-2 text-sm text-purple-800 hidden" style="display: none;">
      <p class="font-medium">선택된 날짜:</p>
      <p id="selectedDates" class="mt-1"></p>
    </div>

    <!-- <p class="text-purple-800 font-bold">가능한 시간을 선택해 주세요</p> -->

    <div class="dropdown-wrapper">
      <div class="custom-dropdown">
        <button id="dropdownMenu1Button" class="w-full bg-white bg-opacity-20 border-0 rounded-lg p-3 text-purple-800 mt-[10px] placeholder-purple-800">
          시작 시간
          <i class="fas fa-chevron-down"></i>
        </button>
        <div id="dropdownMenu1" class="dropdown-menu">
          <!-- 시간 옵션들 추가 -->
          <a href="#">12:00 AM</a>
          <a href="#">01:00 AM</a>
          <a href="#">02:00 AM</a>
          <a href="#">03:00 AM</a>
          <a href="#">04:00 AM</a>
          <a href="#">05:00 AM</a>
          <a href="#">06:00 AM</a>
          <a href="#">07:00 AM</a>
          <a href="#">08:00 AM</a>
          <a href="#">09:00 AM</a>
          <a href="#">10:00 AM</a>
          <a href="#">11:00 AM</a>
          <a href="#">12:00 PM</a>
          <a href="#">01:00 PM</a>
          <a href="#">02:00 PM</a>
          <a href="#">03:00 PM</a>
          <a href="#">04:00 PM</a>
          <a href="#">05:00 PM</a>
          <a href="#">06:00 PM</a>
          <a href="#">07:00 PM</a>
          <a href="#">08:00 PM</a>
          <a href="#">09:00 PM</a>
          <a href="#">10:00 PM</a>
          <a href="#">11:00 PM</a>
        </div>
      </div>
      <div class="text-between">
        <span>부터</span>
      </div>
      <div class="custom-dropdown">
        <button id="dropdownMenu2Button" class="w-full bg-white bg-opacity-20 border-0 rounded-lg p-3 text-purple-800 mt-[10px] placeholder-purple-800">
          종료 시간
          <i class="fas fa-chevron-down"></i>
        </button>
        <div id="dropdownMenu2" class="dropdown-menu">
          <!-- 시간 옵션들 추가 -->
          <a href="#">12:00 AM</a>
          <a href="#">01:00 AM</a>
          <a href="#">02:00 AM</a>
          <a href="#">03:00 AM</a>
          <a href="#">04:00 AM</a>
          <a href="#">05:00 AM</a>
          <a href="#">06:00 AM</a>
          <a href="#">07:00 AM</a>
          <a href="#">08:00 AM</a>
          <a href="#">09:00 AM</a>
          <a href="#">10:00 AM</a>
          <a href="#">11:00 AM</a>
          <a href="#">12:00 PM</a>
          <a href="#">01:00 PM</a>
          <a href="#">02:00 PM</a>
          <a href="#">03:00 PM</a>
          <a href="#">04:00 PM</a>
          <a href="#">05:00 PM</a>
          <a href="#">06:00 PM</a>
          <a href="#">07:00 PM</a>
          <a href="#">08:00 PM</a>
          <a href="#">09:00 PM</a>
          <a href="#">10:00 PM</a>
          <a href="#">11:00 PM</a>
          <a href="#">00:00 AM</a>
        </div>
      </div>
    </div>
    <div class="flex items-center justify-between">
      <p class="text-purple-800 font-bold mt-[15px] mb-[10px]">날짜를 선택해 주세요</p>
      <div class="relative inline-block">
        <button type="button" class="text-purple-800" id="dateHelpBtn">
          <i class="fas fa-question-circle"></i>
        </button>
        <div id="dateHelpTooltip" class="hidden">
          클릭 또는 드래그하여 날짜를 선택합니다.<br/>
          최대 31일까지 선택할 수 있어요.
        </div>
      </div>
    </div>
    <div id="calendar">
      <div class="calendar-nav">
        <button id="prevBtn" aria-label="이전 달">
          <svg width="16" height="16" viewBox="0 0 16 16">
            <polyline points="10,3 5,8 10,13" fill="none" stroke="#4a148c" stroke-width="2"/>
          </svg>
        </button>
        <div class="calendar-header" id="calendarHeader"></div>
        <button id="nextBtn" aria-label="다음 달">
          <svg width="16" height="16" viewBox="0 0 16 16">
            <polyline points="6,3 11,8 6,13" fill="none" stroke="#4a148c" stroke-width="2"/>
          </svg>
        </button>
      </div>
      <table id="calendarTable"></table>
      <button id="todayBtn" class="today-btn">
        <svg width="16" height="16" viewBox="0 0 16 16" style="vertical-align:middle;margin-right:5px;">
          <rect x="2" y="2" width="12" height="12" />
        </svg>
        오늘
      </button>
    </div>
    <button class="w-full py-3 bg-purple-700 text-white rounded-xl" id="nextButton" style="margin-top: 30px;">다음</button>
  </div>

</div>


<footer class="bg-purple-800 text-white py-6">
  <div class="container mx-auto text-center">
    <p class="text-sm">&copy; Made with 💜 by 퍼플코드랩스</p>
  </div>
</footer>

<script>
  document.addEventListener('DOMContentLoaded', function () {
    const dropdown1 = document.getElementById("dropdownMenu1");
    const dropdown1Button = document.getElementById("dropdownMenu1Button");

    const dropdown2 = document.getElementById("dropdownMenu2");
    const dropdown2Button = document.getElementById("dropdownMenu2Button");

    // 드롭다운 메뉴 옵션들을 필터링하는 함수 - 모든 옵션이 보이도록 업데이트
    function updateDropdownFilters() {
      // 시작 시간과 종료 시간 드롭다운의 모든 옵션을 항상 보이도록 설정합니다.
      dropdown1.querySelectorAll("a").forEach(option => {
        option.style.display = "block";
      });
      dropdown2.querySelectorAll("a").forEach(option => {
        option.style.display = "block";
      });
    }

    // 드롭다운 열기/닫기 시 필터 업데이트
    dropdown1Button.addEventListener("click", () => {
      updateDropdownFilters();
      dropdown1.classList.toggle("show");
    });

    dropdown2Button.addEventListener("click", () => {
      updateDropdownFilters();
      dropdown2.classList.toggle("show");
    });

    // 드롭다운 메뉴 항목 클릭 시 선택한 값 반영 및 selected 클래스 추가 후 필터 업데이트
    dropdown1.querySelectorAll("a").forEach((item) => {
      item.addEventListener("click", () => {
        dropdown1Button.textContent = item.textContent;
        dropdown1.classList.remove("show");

        // 기존 선택 삭제 후 현재 항목에 selected 클래스 추가
        dropdown1.querySelectorAll("a").forEach((a) => a.classList.remove("selected"));
        item.classList.add("selected");

        updateDropdownFilters();
        // 드롭다운 선택 시 오류 제거
        const existingStartError = document.getElementById("startDropdownError");
        if(existingStartError) existingStartError.remove();
        dropdown1Button.style.border = "";
      });
    });

    dropdown2.querySelectorAll("a").forEach((item) => {
      item.addEventListener("click", () => {
        dropdown2Button.textContent = item.textContent;
        dropdown2.classList.remove("show");

        // 기존 선택 삭제 후 현재 항목에 selected 클래스 추가
        dropdown2.querySelectorAll("a").forEach((a) => a.classList.remove("selected"));
        item.classList.add("selected");

        updateDropdownFilters();
        // 드롭다운 선택 시 오류 제거
        const existingEndError = document.getElementById("endDropdownError");
        if(existingEndError) existingEndError.remove();
        dropdown2Button.style.border = "";
      });
    });

    (function(){
      const calendarTable = document.getElementById("calendarTable");
      const header = document.getElementById("calendarHeader");
      const todayDate = new Date();
      let currentYear = todayDate.getFullYear();
      let currentMonth = todayDate.getMonth();

      function getSelectionKey(year, month) {
        return "dateSelection_" + year + "-" + (month + 1);
      }

      function saveCurrentSelection() {
        const key = getSelectionKey(currentYear, currentMonth);
        const selections = [];
        const dayCells = calendarTable.querySelectorAll("td.day");
        dayCells.forEach(cell => {
          if(cell.classList.contains("selected")) {
            selections.push(cell.dataset.date);
          }
        });
        localStorage.setItem(key, JSON.stringify(selections));
      }

      function loadSelections(year, month) {
        const key = getSelectionKey(year, month);
        let selections = JSON.parse(localStorage.getItem(key));
        const todayDate = new Date();
        const today = todayDate.getDate();
        const currentMonth = todayDate.getMonth();
        const currentYear = todayDate.getFullYear();

        if (selections && selections.length) {
            const dayCells = calendarTable.querySelectorAll("td.day");
            dayCells.forEach(cell => {
                const cellDate = parseInt(cell.dataset.date);
                const cellMonth = month; // 현재 월을 사용
                const cellYear = year; // 현재 연도 사용

                // 오늘 날짜가 지나면 선택된 날짜를 회색으로 변경
                if (cellYear < todayDate.getFullYear() || 
                    (cellYear === todayDate.getFullYear() && cellMonth < todayDate.getMonth()) || 
                    (cellYear === todayDate.getFullYear() && cellMonth === todayDate.getMonth() && cellDate < today)) {
                    cell.classList.add("disabled"); // 회색으로 표시
                    cell.classList.remove("selected"); // 선택 해제
                } else if (selections.indexOf(cell.dataset.date) !== -1) {
                    cell.classList.add("selected");
                } else {
                    cell.classList.remove("selected");
                }
            });
        }
      }

      function renderCalendar(year, month) {
        const monthNames = ["1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월"];
        header.textContent = year + "년 " + monthNames[month];
        calendarTable.innerHTML = "";

        const thead = document.createElement("thead");
        const headerRow = document.createElement("tr");
        const weekDays = ["일", "월", "화", "수", "목", "금", "토"];
        weekDays.forEach(day => {
          const th = document.createElement("th");
          th.textContent = day;
          headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);
        calendarTable.appendChild(thead);

        const tbody = document.createElement("tbody");
        const firstDay = new Date(year, month, 1).getDay();
        const totalDays = new Date(year, month + 1, 0).getDate();
        let date = 1;
        for (let i = 0; i < 6; i++) {
          const tr = document.createElement("tr");
          for (let j = 0; j < 7; j++) {
            const td = document.createElement("td");
            if (i === 0 && j < firstDay) {
              td.className = "empty";
              td.textContent = "";
            } else if (date > totalDays) {
              td.className = "empty";
              td.textContent = "";
            } else {
              td.dataset.date = date;
              td.classList.add("day");
              // 오늘 날짜보다 이전이면 disabled 클래스 추가
              if (
                      year < todayDate.getFullYear() ||
                      (year === todayDate.getFullYear() && month < todayDate.getMonth()) ||
                      (year === todayDate.getFullYear() && month === todayDate.getMonth() && date < todayDate.getDate())
              ) {
                td.classList.add("disabled");
              }
              const circle = document.createElement("div");
              circle.classList.add("circle");
              circle.textContent = date;
              td.appendChild(circle);
              if (year === todayDate.getFullYear() && month === todayDate.getMonth() && date === todayDate.getDate()) {
                td.classList.add("today");
              }
              date++;
            }
            tr.appendChild(td);
          }
          tbody.appendChild(tr);
        }
        calendarTable.appendChild(tbody);

        loadSelections(year, month);
        updateSelectedDates();
      }

      renderCalendar(currentYear, currentMonth);

      document.getElementById("prevBtn").addEventListener("click", function(){
        saveCurrentSelection();
        currentMonth--;
        if(currentMonth < 0){
          currentMonth = 11;
          currentYear--;
        }
        renderCalendar(currentYear, currentMonth);
      });

      document.getElementById("nextBtn").addEventListener("click", function(){
        saveCurrentSelection();
        currentMonth++;
        if(currentMonth > 11){
          currentMonth = 0;
          currentYear++;
        }
        renderCalendar(currentYear, currentMonth);
      });

      document.getElementById("todayBtn").addEventListener("click", function(){
        saveCurrentSelection();
        currentYear = todayDate.getFullYear();
        currentMonth = todayDate.getMonth();
        renderCalendar(currentYear, currentMonth);
      });

      let isMouseDown = false;
      let isTouchActive = false;
      let dragStartDay = null;
      let dragMode = "add";
      let initialSelected = new Map();

      function findDayCell(target) {
        if(target.classList.contains("day")) return target;
        if(target.parentElement && target.parentElement.classList.contains("day")) return target.parentElement;
        return null;
      }

      function getTotalSelectedAcrossAllPages() {
        let total = 0;
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key.startsWith("dateSelection_")) {
            const selections = JSON.parse(localStorage.getItem(key)) || [];
            total += selections.length;
          }
        }
        return total;
      }

      let calendarErrorTimeoutId; // 달력 에러 타이머를 저장할 변수

      // 에러 애니메이션 재호출 시 기존 애니메이션 취소 후 새로운 애니메이션 실행
      function showCalendarSelectionError() {
        const calendarDiv = document.getElementById("calendar");

        // 기존 타이머가 있다면 취소 후 애니메이션 클래스 제거
        if (calendarErrorTimeoutId) {
          clearTimeout(calendarErrorTimeoutId);
          calendarErrorTimeoutId = null;
          calendarDiv.classList.remove("shake-error");
          // 강제로 리플로우하여 애니메이션 재시작 가능하도록 함
          void calendarDiv.offsetWidth;
        }

        // 기존 오류 메시지 제거
        let existingError = document.getElementById("calendarSelectionError");
        if (existingError) existingError.remove();

        // 달력 컨테이너의 위치 설정(상대 위치 필요)
        const container = calendarDiv.parentElement;
        if (getComputedStyle(container).position === "static") {
          container.style.position = "relative";
        }

        // 에러 상태 스타일 적용
        calendarDiv.style.border = "2px solid #d32f2f";

        const errorMsg = document.createElement("div");
        errorMsg.setAttribute("id", "calendarSelectionError");
        errorMsg.style.color = "#d32f2f";
        errorMsg.style.fontSize = "0.75em";
        errorMsg.style.position = "absolute";
        const topPosition = calendarDiv.offsetTop + calendarDiv.offsetHeight + 4;
        errorMsg.style.top = topPosition + "px";
        errorMsg.style.left = calendarDiv.offsetLeft + "px";
        errorMsg.style.width = calendarDiv.offsetWidth + "px";
        errorMsg.style.zIndex = "10";
        errorMsg.textContent = "최대 31일까지만 선택할 수 있습니다.";

        container.appendChild(errorMsg);

        // shake-error 클래스를 사용하여 애니메이션 적용
        calendarDiv.classList.add("shake-error");
        calendarErrorTimeoutId = setTimeout(() => {
          calendarDiv.classList.remove("shake-error");
          if (errorMsg.parentNode) {
            calendarDiv.style.border = "";
            errorMsg.remove();
          }
          calendarErrorTimeoutId = null;
        }, 1000); // 지연 시간을 1초로 줄임
      }

      function handleDragStart(e) {
        const touch = e.type.includes('touch') ? e.touches[0] : e;
        const dayCell = findDayCell(document.elementFromPoint(touch.clientX, touch.clientY));
        if (dayCell && dayCell.classList.contains("disabled")) return;
        if (dayCell && dayCell.classList.contains("day")) {
          isMouseDown = true;
          isTouchActive = e.type.includes('touch');
          dragStartDay = parseInt(dayCell.dataset.date);
          initialSelected.clear();
          const dayCells = Array.from(calendarTable.querySelectorAll("td.day"));
          dayCells.forEach(cell => {
            initialSelected.set(cell, cell.classList.contains("selected"));
          });
          dragMode = dayCell.classList.contains("selected") ? "remove" : "add";

          if (dragMode === "add") {
            const currentMonthKey = getSelectionKey(currentYear, currentMonth);
            const currentMonthSaved = JSON.parse(localStorage.getItem(currentMonthKey)) || [];
            const currentMonthSavedCount = currentMonthSaved.length;
            let currentPageCount = 0;
            dayCells.forEach(cell => {
              if (cell.classList.contains("selected")) currentPageCount++;
            });
            const totalStored = getTotalSelectedAcrossAllPages();
            const otherPagesCount = totalStored - currentMonthSavedCount;
            const overallSelectedCount = otherPagesCount + currentPageCount;
            if (overallSelectedCount >= 31) {
              showCalendarSelectionError();
              isMouseDown = false;
              return;
            }
            dayCell.classList.add("selected");
          } else {
            dayCell.classList.remove("selected");
          }
          removeCalendarError();
          e.preventDefault();
        }
      }

      function handleDragMove(e) {
        if (!isMouseDown) return;
        const touch = e.type.includes('touch') ? e.touches[0] : e;
        const dayCell = findDayCell(document.elementFromPoint(touch.clientX, touch.clientY));
        if (dayCell && dayCell.classList.contains("day")) {
          if (dayCell.classList.contains("disabled")) return;
          const currentDay = parseInt(dayCell.dataset.date);
          const minDay = Math.min(dragStartDay, currentDay);
          const maxDay = Math.max(dragStartDay, currentDay);
          const allDayCells = Array.from(calendarTable.querySelectorAll("td.day"));

          const currentMonthKey = getSelectionKey(currentYear, currentMonth);
          const currentMonthSaved = JSON.parse(localStorage.getItem(currentMonthKey)) || [];
          const currentMonthSavedCount = currentMonthSaved.length;
          let currentPageCount = 0;
          allDayCells.forEach(cell => {
            if (cell.classList.contains("selected")) currentPageCount++;
          });
          const totalStored = getTotalSelectedAcrossAllPages();
          const otherPagesCount = totalStored - currentMonthSavedCount;
          let overallSelectedCount = otherPagesCount + currentPageCount;

          allDayCells.forEach(cell => {
            if (cell.classList.contains("disabled")) return;
            const cellDay = parseInt(cell.dataset.date);
            if (cellDay >= minDay && cellDay <= maxDay) {
              if (dragMode === "add") {
                if (!cell.classList.contains("selected")) {
                  if (overallSelectedCount < 31) {
                    cell.classList.add("selected");
                    overallSelectedCount++;
                  } else {
                    showCalendarSelectionError();
                    cell.classList.remove("selected");
                  }
                }
              } else {
                if (cell.classList.contains("selected")) {
                  cell.classList.remove("selected");
                  overallSelectedCount = Math.max(0, overallSelectedCount - 1);
                }
              }
            } else {
              if (initialSelected.get(cell)) {
                cell.classList.add("selected");
              } else {
                cell.classList.remove("selected");
              }
            }
          });
        }
        e.preventDefault();
      }

      function handleDragEnd(e) {
        if(isMouseDown){
          isMouseDown = false;
          isTouchActive = false;
          dragStartDay = null;
          initialSelected.clear();
          saveCurrentSelection();
          removeCalendarError();
          updateSelectedDates();
        }
      }

      // 수정된 removeCalendarError 함수
      function removeCalendarError() {
        const calendarDiv = document.getElementById("calendar");
        // 만약 "최대 31일까지만 선택할 수 있습니다." 에러 메시지가 존재하면 제거하지 않음
        const selectionError = document.getElementById("calendarSelectionError");
        if (selectionError) {
          return;
        }
        const calendarError = document.getElementById("calendarError");
        const selectedDays = calendarTable.querySelectorAll("td.day.selected");
        if (selectedDays.length > 0 && selectedDays.length <= 31) {
          calendarDiv.style.border = "";
          if (calendarError) {
            calendarError.remove();
          }
        }
      }

      // 이벤트 리스너 등록 (중복 제거)
      calendarTable.addEventListener("mousedown", handleDragStart);
      calendarTable.addEventListener("mousemove", handleDragMove);
      document.addEventListener("mouseup", handleDragEnd);

      calendarTable.addEventListener("touchstart", handleDragStart, { passive: false });
      calendarTable.addEventListener("touchmove", handleDragMove, { passive: false });
      document.addEventListener("touchend", handleDragEnd);
      document.addEventListener("touchcancel", handleDragEnd);

      // 클릭 이벤트는 별도로 유지 (드래그와 관계없이 단일 클릭 처리)
      calendarTable.addEventListener("click", function(e) {
        removeCalendarError();
        updateSelectedDates();
      });

      // 수정된 updateSelectedDates 함수: localStorage에 저장된 모든 선택 날짜를 불러와 정렬 및 표시
      function updateSelectedDates() {
        const selectedDatesContainer = document.getElementById('selectedDatesContainer');
        const selectedDatesElement = document.getElementById('selectedDates');

        let allDates = [];
        // localStorage의 모든 키를 순회하면서 "dateSelection_" 접두어가 있는 항목만 처리
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key.startsWith("dateSelection_")) {
            // 예: key = "dateSelection_2023-8"
            const keyParts = key.slice("dateSelection_".length).split('-');
            const year = parseInt(keyParts[0], 10);
            const month = parseInt(keyParts[1], 10); // month는 (월+1)
            const days = JSON.parse(localStorage.getItem(key));
            days.forEach(day => {
              allDates.push({ year: year, month: month, day: parseInt(day, 10) });
            });
          }
        }

        if (allDates.length > 0) {
          // 날짜 순서대로 정렬 (연·월·일)
          allDates.sort((a, b) => {
            if (a.year !== b.year) return a.year - b.year;
            if (a.month !== b.month) return a.month - b.month;
            return a.day - b.day;
          });

          // 연속된 날짜를 그룹화하는 함수
          function groupConsecutiveDates(dates) {
            const groups = [];
            let currentGroup = [dates[0]];
            for (let i = 1; i < dates.length; i++) {
              const prev = dates[i - 1];
              const curr = dates[i];
              // Date 객체로 변환 후 일수 차이 계산 (연속적이면 diff === 1)
              const prevDate = new Date(prev.year, prev.month - 1, prev.day);
              const currDate = new Date(curr.year, curr.month - 1, curr.day);
              const diff = (currDate - prevDate) / (1000 * 60 * 60 * 24);
              if (diff === 1) {
                currentGroup.push(curr);
              } else {
                groups.push(currentGroup);
                currentGroup = [curr];
              }
            }
            groups.push(currentGroup);
            return groups;
          }

          const groups = groupConsecutiveDates(allDates);

          // 각 그룹별 출력 형식 결정: 연속이면 "첫날 ~ 마지막날", 아니면 개별 날짜
          const dateStrings = groups.map(group => {
            if (group.length > 1) {
              const first = group[0];
              const last = group[group.length - 1];
              return `${first.year}년 ${first.month}월 ${first.day}일 ~ ${last.year}년 ${last.month}월 ${last.day}일`;
            } else {
              const d = group[0];
              return `${d.year}년 ${d.month}월 ${d.day}일`;
            }
          });

          // 기본 스타일 그대로 (콤마로 구분)
          selectedDatesElement.textContent = dateStrings.join(', ');
          selectedDatesContainer.classList.remove('hidden');
        } else {
          selectedDatesContainer.classList.add('hidden');
        }
      }
    })();

    // --- 검증 및 경고문구 출력 ---
    function parseTime(timeStr) {
      // 만약 "00:00 AM"이면 다음 날의 자정(24:00)을 의미하도록 1440 반환
      if (timeStr.trim() === "00:00 AM") {
        return 24 * 60;
      }
      const parts = timeStr.split(' ');
      if (parts.length < 2) return NaN;
      const timePart = parts[0];
      const period = parts[1].toUpperCase();
      let [hour, minute] = timePart.split(':').map(Number);
      if (period === "AM" && hour === 12) {
        hour = 0;
      } else if (period === "PM" && hour < 12) {
        hour += 12;
      }
      return hour * 60 + minute;
    }

    function validateForm() {
      let isValid = true;
      let firstErrorElement = null;

      // 일정 제목 검증
      const titleInput = document.getElementById("titleInput");
      const existingTitleError = document.getElementById("titleError");
      if(existingTitleError) {
        existingTitleError.remove();
      }
      titleInput.style.border = "";
      if(titleInput.value.trim() === ""){
        isValid = false;
        titleInput.style.border = "2px solid #d32f2f";
        titleInput.classList.add("shake-error");
        setTimeout(() => titleInput.classList.remove("shake-error"), 400);
        const errorMsg = document.createElement("div");
        errorMsg.setAttribute("id", "titleError");
        errorMsg.style.color = "#d32f2f";
        errorMsg.style.fontSize = "0.75em";
        errorMsg.style.margin = "1px 0 0 0";
        errorMsg.style.position = "relative";
        errorMsg.textContent = "일정 제목을 입력해주세요.";
        titleInput.parentNode.insertBefore(errorMsg, titleInput.nextSibling);
        if (!firstErrorElement) firstErrorElement = titleInput;
      }

      // 시작시간 드롭다운 검증
      const startTimeButton = document.getElementById("dropdownMenu1Button");
      const existingStartError = document.getElementById("startDropdownError");
      if(existingStartError) {
        existingStartError.remove();
      }
      startTimeButton.style.border = "";
      if(startTimeButton.textContent.trim() === "시작 시간"){
        isValid = false;
        startTimeButton.style.border = "2px solid #d32f2f";
        startTimeButton.classList.add("shake-error");
        setTimeout(() => startTimeButton.classList.remove("shake-error"), 400);
        const errorMsg = document.createElement("div");
        errorMsg.setAttribute("id", "startDropdownError");
        errorMsg.style.color = "#d32f2f";
        errorMsg.style.fontSize = "0.75em";
        errorMsg.style.margin = "1px 0 0 0";
        errorMsg.style.whiteSpace = "nowrap";
        errorMsg.textContent = "시작시간을 선택해주세요.";
        startTimeButton.parentNode.style.overflow = "visible";
        startTimeButton.parentNode.insertBefore(errorMsg, startTimeButton.nextSibling);
        if (!firstErrorElement) firstErrorElement = startTimeButton;
      }

      // 종료시간 드롭다운 검증
      const endTimeButton = document.getElementById("dropdownMenu2Button");
      const existingEndError = document.getElementById("endDropdownError");
      if(existingEndError) {
        existingEndError.remove();
      }
      endTimeButton.style.border = "";
      if(endTimeButton.textContent.trim() === "종료 시간"){
        isValid = false;
        endTimeButton.style.border = "2px solid #d32f2f";
        endTimeButton.classList.add("shake-error");
        setTimeout(() => endTimeButton.classList.remove("shake-error"), 400);
        const errorMsg = document.createElement("div");
        errorMsg.setAttribute("id", "endDropdownError");
        errorMsg.style.color = "#d32f2f";
        errorMsg.style.fontSize = "0.75em";
        errorMsg.style.margin = "1px 0 0 0";
        errorMsg.style.whiteSpace = "nowrap";
        errorMsg.textContent = "종료시간을 선택해주세요.";
        endTimeButton.parentNode.style.overflow = "visible";
        endTimeButton.parentNode.insertBefore(errorMsg, endTimeButton.nextSibling);
        if (!firstErrorElement) firstErrorElement = endTimeButton;
      }

      // 시작 시간과 종료 시간의 순서 검증 : 시작 시간이 종료 시간보다 늦을 경우
      if(startTimeButton.textContent.trim() !== "시작 시간" && endTimeButton.textContent.trim() !== "종료 시간"){
        const startTimeValue = parseTime(startTimeButton.textContent.trim());
        const endTimeValue = parseTime(endTimeButton.textContent.trim());
        if(startTimeValue >= endTimeValue){
          isValid = false;

          // 시작 시간 에러 처리
          startTimeButton.style.border = "2px solid #d32f2f";
          startTimeButton.classList.add("shake-error");
          setTimeout(() => startTimeButton.classList.remove("shake-error"), 400);
          let errStart = document.getElementById("startDropdownError");
          if(errStart) errStart.remove();
          const errorMsgTime = document.createElement("div");
          errorMsgTime.setAttribute("id", "startDropdownError");
          errorMsgTime.style.color = "#d32f2f";
          errorMsgTime.style.fontSize = "0.75em";
          errorMsgTime.style.margin = "1px 0 0 0";
          errorMsgTime.style.whiteSpace = "nowrap";
          errorMsgTime.textContent = "시작시간이 종료시간보다 늦을수 없습니다.";
          startTimeButton.parentNode.style.overflow = "visible";
          startTimeButton.parentNode.insertBefore(errorMsgTime, startTimeButton.nextSibling);

          // 종료 시간 에러 처리
          endTimeButton.style.border = "2px solid #d32f2f";
          endTimeButton.classList.add("shake-error");
          setTimeout(() => endTimeButton.classList.remove("shake-error"), 400);
          let errEnd = document.getElementById("endDropdownError");
          if(errEnd) errEnd.remove();
          const errorMsgTime2 = document.createElement("div");
          errorMsgTime2.setAttribute("id", "endDropdownError");
          errorMsgTime2.style.color = "#d32f2f";
          errorMsgTime2.style.fontSize = "0.75em";
          errorMsgTime2.style.margin = "1px 0 0 0";
          errorMsgTime2.style.whiteSpace = "nowrap";
          endTimeButton.parentNode.style.overflow = "visible";
          endTimeButton.parentNode.insertBefore(errorMsgTime2, endTimeButton.nextSibling);

          if (!firstErrorElement) firstErrorElement = startTimeButton;
        }
      }

      // 날짜 선택 검증 (캘린더)
      const calendarDiv = document.getElementById("calendar");
      const existingCalendarError = document.getElementById("calendarError");
      if(existingCalendarError) {
        existingCalendarError.remove();
      }
      calendarDiv.style.border = "";

      // localStorage에 저장된 전체 선택된 날짜 개수를 계산 (모든 "dateSelection_" 키에서)
      let totalSelectedCount = 0;
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key.startsWith("dateSelection_")) {
          const days = JSON.parse(localStorage.getItem(key)) || [];
          totalSelectedCount += days.length;
        }
      }
      
      if(totalSelectedCount === 0 || totalSelectedCount > 31){
        isValid = false;
        calendarDiv.style.border = "2px solid #d32f2f";
        calendarDiv.classList.add("shake-error");
        setTimeout(() => calendarDiv.classList.remove("shake-error"), 400);
        const errorMsg = document.createElement("div");
        errorMsg.setAttribute("id", "calendarError");
        errorMsg.style.color = "#d32f2f";
        errorMsg.style.fontSize = "0.75em";
        errorMsg.style.margin = "1px 0 0 0";
        errorMsg.style.position = "relative";
        errorMsg.textContent = "날짜를 선택해주세요.";
        calendarDiv.parentNode.insertBefore(errorMsg, calendarDiv.nextSibling);
        if (!firstErrorElement) firstErrorElement = calendarDiv;
      }

      // 마지막에 첫 번째 오류 요소로 스크롤
      if (!isValid && firstErrorElement) {
        firstErrorElement.scrollIntoView({
          behavior: 'smooth',
          block: 'center'
        });
      }

      return isValid;
    }

    document.getElementById("nextButton").addEventListener("click", function(e) {
      e.preventDefault();
      if (validateForm()) {
        location.href='/select-time';
      }
    });

    const helpBtn = document.getElementById('dateHelpBtn');
    const tooltip = document.getElementById('dateHelpTooltip');
    let isTooltipVisible = false;
    const defaultDiamondOffset = 10; // 기본값: tooltip 우측에서 떨어진 거리

    function updateTooltipPosition() {
      const helpBtnRect = helpBtn.getBoundingClientRect();
      const offsetParent = tooltip.offsetParent;
      let parentLeft = 0;
      let parentWidth = window.innerWidth;
      if (offsetParent) {
        const parentRect = offsetParent.getBoundingClientRect();
        parentLeft = parentRect.left;
        parentWidth = parentRect.width;
      }
      // 부모 기준 물음표 아이콘의 중앙 x좌표
      const iconCenterX = helpBtnRect.left + (helpBtnRect.width / 2) - parentLeft;

      // tooltip이 보인 상태여야 실제 너비를 읽을 수 있음
      const tooltipRect = tooltip.getBoundingClientRect();

      // 툴크 네모의 우측 상단(마름모 중심이 6px 안쪽)에 맞추기 위한 기본 계산
      let tooltipLeft = iconCenterX - tooltipRect.width + 6;

      const extraOffset = 10;  // 오른쪽으로 10px 이동
      tooltipLeft += extraOffset;

      const margin = 10; // 부모 내부 최소 여백
      // 부모 영역을 벗어나지 않도록 clamping
      if (tooltipLeft < margin) {
        tooltipLeft = margin;
      }
      if (tooltipLeft + tooltipRect.width > parentWidth - margin) {
        tooltipLeft = parentWidth - margin - tooltipRect.width;
      }

      // diamond의 위치 재계산:
      // tooltip 내부에서 diamond의 center는
      // tooltipRect.width - (diamondOffset + 6) 이어야 하고,
      // 이 값이 iconCenterX - tooltipLeft와 일치해야 함
      // 따라서 diamondOffset = tooltipRect.width - (iconCenterX - tooltipLeft) - 6
      const diamondOffset = tooltipRect.width - (iconCenterX - tooltipLeft) - 6;

      // 위에서 계산한 tooltipLeft와 diamondOffset 값을 적용
      tooltip.style.left = `${tooltipLeft}px`;
      tooltip.style.setProperty('--diamond-offset', `${diamondOffset}px`);
    }

    // 물음표 아이콘 클릭 시, 툴크 토글 및 위치 업데이트
    helpBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      isTooltipVisible = !isTooltipVisible;
      tooltip.style.display = isTooltipVisible ? 'block' : 'none';
      if (isTooltipVisible) {
        // 툴크가 렌더링된 후 위치 계산
        setTimeout(updateTooltipPosition, 0);
      }
    });

    // 화면 크기 변경 시 툴팁 위치 재계산
    window.addEventListener('resize', function() {
      if (isTooltipVisible) updateTooltipPosition();
    });

    // 툴팁 외부 클릭 시 닫기
    document.addEventListener('click', function(e) {
      if (!tooltip.contains(e.target) && e.target !== helpBtn) {
        isTooltipVisible = false;
        tooltip.style.display = 'none';
      }
    });

    // ESC 키 입력 시 닫기
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape') {
        isTooltipVisible = false;
        tooltip.style.display = 'none';
      }
    });

    // 제목 입력 필드 오류 제거 함수
    function handleTitleError() {
      const titleInput = document.getElementById("titleInput");
      const titleError = document.getElementById("titleError");

      if(titleInput.value.trim() !== "") {
        // 텍스트가 있으면 오류 제거
        titleInput.style.border = "";
        if(titleError) {
          titleError.remove();
        }
      } else {
        // 텍스트가 없으면 오류 표시
        titleInput.style.border = "2px solid #d32f2f";
        titleInput.classList.add("shake-error");
        setTimeout(() => titleInput.classList.remove("shake-error"), 400);

        if(!titleError) {
          const errorMsg = document.createElement("div");
          errorMsg.setAttribute("id", "titleError");
          errorMsg.style.color = "#d32f2f";
          errorMsg.style.fontSize = "0.75em";
          errorMsg.style.margin = "1px 0 0 0";
          errorMsg.style.position = "relative";
          errorMsg.textContent = "일정 제목을 입력해주세요.";
          titleInput.parentNode.insertBefore(errorMsg, titleInput.nextSibling);
        }
      }
    }

    // 제목 입력 필드에 이벤트 리스너 추가
    document.getElementById("titleInput").addEventListener("input", function() {
      handleTitleError();
    });
  });
</script>
</body>
</html>
